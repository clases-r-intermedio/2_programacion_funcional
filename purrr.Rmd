---
title: "Capacitaci칩n paquete calidad"
subtitle: "calidad"
author: 
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    seal: false
    #lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: False
      ratio: '13:9'
---

class: center, middle

.linea-superior[]
.linea-inferior[]

<img src="imagenes/logo_portada2.png" width="200" />

## Capacitaci칩n en R y herramientas de productividad - nivel intermedio

## Proyecto Ciencia de Datos

## Funcionales

```{r setup, include=FALSE}
options(htmltools.dir.version = TRUE)
knitr::opts_chunk$set(message = FALSE, warning = F) 
options(scipen = "999")

```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
library(tidyverse)
library(feather)
xaringanExtra::use_clipboard()
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Estructura de la clase

**Contenidos de la clase**


- Programaci칩n con `dplyr` (evaluaciones no est치ndar)


- Funcionales



---


class: inverse, center, middle

# I. Programaci칩n con dplyr


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci칩n a la programaci칩n con dplyr

### 쮿an intentado programar una funci칩n usando dplyr?

--

### Queremos una funci칩n que calcule m칤nimo, m치ximo, media y mediana en un `dataframe` 

```{r, error = T}
library(gapminder)
library(tidyverse)
calcular_cosas <- function(data, var) {
  data %>% 
    summarise(min = min(var),
              max = max(var),
              mean = mean(var),
              median = median(var)
              )
}

calcular_cosas(gapminder, pop)

```


.center[
<img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" />
]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci칩n a la programaci칩n con dplyr

### Cambiemos un par de cosas


```{r}
library(rlang)
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) #<<

  data %>% 
    summarise(min = min(!!enquo_var), #<<
              max = max(!!enquo_var),
              mean = mean(!!enquo_var),
              median = median(!!enquo_var)
              )
}
calcular_cosas(gapminder, pop)

```

--

### Durante este taller revisaremos `!!` y `enexpr`


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Evaluaciones no est치ndar

### En `R`, los argumentos pueden ser *evaluados* o *quoted* (쯖itados?)  

- evaluados: situaci칩n m치s usual en R
- quoted: los argumentos son procesados de una manera "at칤pica" (evaluaci칩n no est치ndar)

--

### Para saber si un argumento es quoted o evaluado, simplemente ejecutamos el argumento fuera de la funci칩n

```{r, error=T}
pop
```
--

### Si la ejecuci칩n no funciona, el argumento es quoted


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejemplos de argumentos quoted y evaluados

### Argumentos evaluados

```{r, eval = F}
sum(mtcars$am)
class(mtcars)
```

--

### Argumentos quoted

```{r, eval=F}
library(dplyr)

by_cyl <- mtcars %>%
  summarise(mean = mean(mpg)) 

calcular_cosas(gapminder, pop) #<<

```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

### Evaluar de manera no est치ndar consiste en atrapar expresiones y evaluarlas en otro momento

```{r}
expr(x + y)

```
--

### `expr` ha "encapsulado" la expresi칩n `x + y`

--

```{r}
devolver_expresion <- function(x) {
  expr(x)}
devolver_expresion(a + b)
```
### La funci칩n `expr` es demasiado literal. Podemos usar enexpr (enrich) 

```{r}
devolver_expresion <- function(x) {
  enexpr(x)
}
devolver_expresion(a + b)
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

### Volviendo a nuestra funci칩n `calcular_cosas`...
 
```{r, eval=F}
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) #<<

  data %>% 
    summarise(min = min(!!enquo_var),
              max = max(!!enquo_var),
              mean = mean(!!enquo_var),
              median = median(!!enquo_var)
              )
}

```

--

### Ya sabemos qu칠 significa la primera l칤nea


--


```{r}
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) 
  return(enquo_var)
}
calcular_cosas(var = pop)
```





---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

.pull-left[
### 쯈u칠 significa esto `min(!!enquo_var)`?
]

.pull-right[
<img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" />
]


--

### Una vez que la expresi칩n se "congela", es necesario evaluarla

### El operador bang-bang (!!) hace *unquoting*

--

```{r}
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) 

  data %>% 
    summarise(min = min(!!enquo_var)) #<<
}
calcular_cosas(gapminder, pop)
```

### Estamos evaluando la variable enquo_var

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usar el c칩digo del usuario 

### 쯈u칠 pasa si queremos una funci칩n que use el nombre de un par치metro, para nombrar una variable?


### Idea n칰mero 1

```{r}

calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) 

  data %>% 
    summarise(var = min(!!enquo_var)) #<<
}
calcular_cosas(gapminder, pop)



```

--

### Funciona, pero `R` fue demasiado literal. Us칩 el nombre "var"

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usar el c칩digo del usuario 

### Idea n칰mero 2: evaluar *enquo_var* 

```{r, error=T}
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) 

  data %>% 
    summarise(!!enquo_var = min(!!enquo_var)) #<<
}
calcular_cosas(gapminder, pop)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operador :=

### Debemos resolver el problema con un nuevo operador

```{r}
calcular_cosas <- function(data, var) {
  enquo_var <- enexpr(var) 
  data %>% 
    summarise(!!enquo_var := min(!!enquo_var))} #<<
calcular_cosas(gapminder, pop)
```
--

Si queremos entregar un string como input podemos usar `sym` 

`sym` convierte un string en un s칤mbolo. Esta operaci칩n se denomina *parsing*

```{r}
calcular_cosas <- function(data, var) {
  enquo_var <- sym(var)
  data %>% 
    summarise(!!enquo_var  := min(!!enquo_var))} #<<
calcular_cosas(gapminder, "pop")

```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Parsing


### Otra opci칩n es usar la funci칩n `parse_expr` de `rlang`

```{r}
calcular_cosas <- function(data, var) {
  enquo_var <- parse_expr(var)  #<<
  data %>% 
    summarise(!!enquo_var  := min(!!enquo_var))
}
calcular_cosas(gapminder, "pop")

```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Nueva sintaxis

### Hace un tiempo existe el operador embrace `{{}}`

```{r}
calcular_cosas <- function(data, var) {
  data %>% 
    summarise({{var}} := min({{var}})) #<<
}
calcular_cosas(gapminder, pop)
```

--

### Este operador nos hubiera evitado la vuelta que dimos, pero no habr칤amos aprendido sobre evaluaciones no est치ndar 

.center[
# 游뱁

]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio dplyr

Trabajaremos con los datos de Casen. Escriba una funci칩n llamada `sum_something` que agrupe por una variable y sume otra. Por ejemplo, `sum_something(casen, region, ytotcor)` deber칤a devolver lo siguiente:

```{r,echo=FALSE}
casen <- read_feather("data/casen_2020_edit.feather")

sum_something <- function(data, group_var, var) {
  data %>% 
    group_by(!!enexpr(group_var)) %>% 
    summarise(n = sum(!!enexpr(var)))
}
sum_something(casen, region, ytotcor) %>% slice(1:3)

```

--

```{r}
sum_something <- function(data, group_var, var) {
  data %>% 
    group_by(!!enexpr(group_var)) %>% 
    summarise(n = sum(!!enexpr(var)))
}

```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio dplyr (continuaci칩n)

Crea una funci칩n `plot_table` que acompa침e a `sum_something`. `plot_table` debe recibir la tabla creada por `sum_something` y devolver un gr치fico de barras. Es importante que la funci칩n reciba el nombre de la variable x y la variable y. Adem치s, debe existir un par치metro para agregar un t칤tulo al gr치fico. El llamado a la funci칩n `plot_table(table, region, n,  "Total del ingreso por regi칩n" )` deber칤a tener este resultado 

.pull-left[

```{r, echo=F, fig.height=5, fig.width=4.5}

tabla <- sum_something(casen, region, ytotcor)

plot_table <- function(table, x_var, y_var,  input_title ) {
  ggplot(table, aes(x = !!enexpr(x_var), y = !!enexpr(y_var) )) +
    geom_bar(stat = "identity") +
    labs(title = input_title)
}

plot_table(tabla, region, n,  "Total del ingreso por regi칩n" )



```

]

--

.pull-right[

```{r, eval=F}
tabla <- sum_something(casen, region, ytotcor)
plot_table <- function(table, x_var, y_var,  input_title ) {
  ggplot(table, aes(x = !!enexpr(x_var), y = !!enexpr(y_var) )) +
    geom_bar(stat = "identity") +
    labs(title = input_title)
}

plot_table(tabla, region, n,  "Total del ingreso por regi칩n" )

```

]



---


class: inverse, center, middle

# II. functionals 

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci칩n a funcionales (functionals)


*"To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs."*

- Bjarne Stroustrup

--

Una "funcional" (*functional*) es una funci칩n que recibe como input otra funci칩n

```{r}
randomise <- function(f) f(runif(10))
```
--

`randomise` recibe una funci칩n y hace algo con un vector de 10 n칰meros aleatorios

```{r}
randomise(mean)
randomise(sum)
randomise(median)
```





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci칩n a funcionales (functionals)

Es muy probable que ustedes hayan usado funcionales con `R` base

- `apply`, `lapply`, `sapply` 

--

Los *loops* tienen mala fama en `R`

--

T칤picamente, las funcionales se usan como alternativa a los *loops*

--

Nosotros trabajaremos con el paquete `purrr`

```{r}
library(purrr)
```


.center[
<img src="imagenes/purrr.png" width="200" />
]



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mi primera funcional

Funci칩n que calcula el cuadrado del input

```{r}
cuadrado <- function(x) x ** 2
```

--

`map` lleva el vector `1:3` hacia la funci칩n cuadrado

```{r}
map(1:3, cuadrado)
```



.center[
<img src="https://d33wubrfki0l68.cloudfront.net/f0494d020aa517ae7b1011cea4c4a9f21702df8b/2577b/diagrams/functionals/map.png" width="200" />
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 쯈u칠 tienen que ver los mapas?

.center[
<img src="imagenes/mapa.png" width="400" />
]


--

.center[
<img src="imagenes/mapear_funcion.png" width="400" />
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ventajas de purrr

Permite abstraernos de lo que hace la funci칩n

--

Tenemos claridad de lo que entra y sale de la funci칩n 

- `map` devuelve una lista
- `map_int` devuelve vector de enteros
- `map_dbl` devuelve vector de reales
- `map_chr` devuelve vector de characters
- `map_df` devuelve un dataframe

 

```{r, error=T}
triple_chr <- function(x) as.character(x * 3)
map_int(1:3, triple_chr)
```
```{r}
map_chr(1:3, triple_chr)
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con listas anidadas

### La funci칩n `mean` se eval칰a en cada uno de los vectores de la lista

```{r}
lista_vectores <- list(1:3, 1:10, 2:9, 1)
map_dbl(lista_vectores, mean)
```
--

### 쮺칩mo uso esto en un dataframe?


.center[
<img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" />
]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con dataframes

### En `R`, los `dataframes` son listas con vectores de la misma longitud

```{r}
typeof(mtcars)
```
--

```{r}
map_dbl(mtcars, mean)
```

.center[
<img src="https://media.giphy.com/media/l3V0dy1zzyjbYTQQM/giphy.gif" width="250" />
]





---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con m치s argumentos

### 쯈u칠 pasa si queremos usar m치s argumentos?

```{r}
lista_vectores <- list(1:3, c(1:10, NA))
map_dbl(lista_vectores, ~mean(.x, na.rm = TRUE))
```

`.x` toma el valor de los elementos que est치n dentro de `lista_vectores` 

El par치metro que var칤a va a la izquierda y el par치metro fijo a la derecha

--

.center[
<img src="https://d33wubrfki0l68.cloudfront.net/e1b3536a7556aef348f546a79277125c419a5fdc/0c0a1/diagrams/functionals/map-arg.png" width="400" />
]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando 2 inputs 

### La funci칩n `media_sumar` calcula la media y suma un valor

```{r}
media_sumar <- function(vector, valor) {
  mean(vector) + valor
}
```

### Queremos que la funci칩n itere sobre `lista_vectores` y sobre `valores`

```{r}
lista_vectores <- list(1:3, 1:5, 2:5)
valores <- c(2, 3, 8)
```

--

```{r}
map2_dbl(lista_vectores, valores, media_sumar)
```

.center[
<img src="https://d33wubrfki0l68.cloudfront.net/f5cddf51ec9c243a7c13732b0ce46b0868bf8a31/501a8/diagrams/functionals/map2.png" width="300" />
]

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio map2

Tenemos una lista muy larga de elementos con nombres inscritos en el registro civil

```{r}
lista_anios <- split(guaguas::guaguas, ~anio )
names(lista_anios)[1:5]

```
Vamos a imaginar que cada elemento ocupa mucha memoria, por lo que deben ser procesados en secuencia

--

La idea es calcular la suma de nombres (variable n) para cada a침o, filtrando por una variable que puede ser hombre o mujer

```{r}
filtro <-  map_chr(1:length(lista_anios), ~sample(x = c("F", "M"), size = 1))
filtro[1:5]
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resultado ejercicio map2


```{r}
totales <- map2(lista_anios, filtro,  ~.x %>% 
      dplyr::filter(sexo == .y) %>% 
      dplyr::summarise(total = sum(n) )
      )
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando *n* cantidad de inputs 

### Necesitamos iterar sobre 3 vectores

```{r}
media_sumar_dividir <- function(vector, valor_suma, valor_division) {
  (mean(vector) + valor_suma) / valor_division
}

lista_vectores <- list(1:3, 1:5, 2:5)
valores_suma <- c(2, 3, 8)
valores_division <- c(2, 1, 9)
```

--

```{r}
pmap_dbl(list(lista_vectores, valores_suma, valores_division), media_sumar_dividir)
```


.center[
<img src="https://d33wubrfki0l68.cloudfront.net/2eb2eefe34ad6d114da2a22df42deac8511b4788/5a538/diagrams/functionals/pmap-arg.png" width="300" />
]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajar con *side-effects* 

### A veces, nos interesa una funci칩n por sus *side-effects*

```{r, eval=T}
animales <- c("perro", "gato", "elefante")
map(animales, print)
```
--

### `map` est치 creando una lista y, adem치s, est치 imprimiendo los valores

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando walk


.center[
<img src="imagenes/walk.jpg" width="350" />
]

--

```{r}
walk(animales, print)
```

### Ahora solo estamos imprimiendo los strings

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando `walk`

### Necesito escribir archivos  

```{r, echo=F}
library(gapminder)
```


```{r}
continentes <- split(gapminder, gapminder$continent)
```

```{r}
library(feather)
files <- paste0("data/", names(continentes), ".feather")
walk2(continentes, files, write_feather)

```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# imap

A veces, es 칰til iterar sobre los nombres de una lista

--

Extraer nombres de archivos y construir etiquetas
```{r}
files <- list.files("data/datos_ene/", full.names = T)
trimestres <- list.files("data/datos_ene/") %>% 
  str_extract(pattern = "-[[:digit:]]{2}-") %>% 
  str_remove_all("-")
```

--

Leer archivos y etiquetar
```{r}
varios_ene <-  map(files, read_csv2 )
names(varios_ene) <-  paste0("trimestre_", trimestres)  
nombres_lista <-  imap(varios_ene, ~.y)
nombres_lista
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# imap

Creamos una variable con el nombre de cada elemento

```{r, error=T}
ocupados <- imap(varios_ene, .f = ~mutate(., .y = if_else(activ == 1, 1, 0) ))
ocupados[[1]] %>% count(trimestre_01)

```

### 쯈u칠 podemos hacer para arreglar el problema?

.center[
<img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" />
]

--

```{r}
ocupados <- imap(varios_ene, .f = ~mutate(., !!rlang::parse_expr(.y)  := if_else(activ == 1, 1, 0) ))
```






---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio: apliquemos todo

Tenemos un listado de `dataframes` separados por a침o  

```{r}
gapminder_list <- split(gapminder, gapminder$year)

```
Retomemos nuestras funciones `sum_something` y `plot_table`. 

La idea es usar `purrr` con el listado que tenemos y generar un gr치fico para cada a침o en el que se muestre la poblaci칩n de cada continente. 

--

```{r}
plots_by_year <- gapminder_list %>% 
  map(~sum_something(.x, continent, pop)) %>% 
  map(~plot_table(.x, continent, n, "Poblaci칩n mundial, seg칰n continente" ))
```

--

```{r}
plots_by_year <- gapminder_list %>% 
  map(sum_something, continent, pop) %>% 
  map(plot_table, continent, n, "Poblaci칩n mundial, seg칰n continente" )

```






---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la 游

Las tareas deber치n ser entregadas a trav칠s de git. En el repositorio de github que hemos estado usando existe una rama llamada tareas, en la cual hay una carpeta para cada clase. Hagan *fetch* (o *pull*) de esa rama y empujen sus tareas a la carpeta correspondiente. La estructura del archivo debe ser la siguiente: nombre_apellido1_apellido2.R

**Nota: Es deseable que las tareas solo contengan funciones**

**Ejercicio 1**

El siguiente c칩digo genera un resultado muy similar al del 칰ltimo ejercicio revisado en la clase. La diferencia es que la implementaci칩n es mediante un ciclo *for*. Adicionalmente, se agrega una funcionalidad que agrega al t칤tulo el a침o correspondiente.     



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la 游 (continuaci칩n ejercicio 1)


```{r, eval=F}
gapminder_list <- split(gapminder, gapminder$year)
plot_with_for <- function(tablas){
  plots <- list(vector(length = length(tablas) ))
  i <- 1
  for (plot in tablas) {
    table <- sum_something(plot, continent, pop)
    plots[[i]] <- plot_table(table, continent, n, paste("Poblaci칩n mundial, seg칰n continente. A침o", plot$year[1] )  )
    i <-  i + 1
  }
  return(plots)
}

```

```{r, eval=F}
plots <- plot_with_for(gapminder_list)
```


La tarea consiste en llegar al mismo resultado, pero utilizando 칰nicamente las herramientas de `purrr`. **Crea una funci칩n llamada plot_with_purrr que reciba una lista de tablas y devuelva una lista de gr치ficos** 

**Pista**: La funci칩n `imap` puede ser de gran ayuda 

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la 游

**Ejercicio 2**

Modifica la funci칩n `plot_table` para que el a침o del gr치fico aparezca en el subt칤tulo y no en el t칤tulo. La funci칩n modificada deber칤a recibir un par치metro extra llamado `subtitulo`, que permita agregar el a침o al subt칤tulo del gr치fico.

Una vez que hayas modificado tu funci칩n, util칤zala dentro de `plot_with_purrr`. Cada gr치fico deber칤a tener el a침o correspondiente en el subt칤tulo.  

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la 游

**Ejercicio 3**

El siguiente *for* anidado genera pares de *x* e *y*. El ejercicio consiste en escribir una funci칩n llamada **nested_map** que utilice una sintaxis de `purrr`. La funci칩n debe recibir dos vectores num칠ricos (de igual o distinto largo) e imprimir pares de n칰mero. 

Es posible que la sintaxis llegue a ser un poco confusa. Reflexiona sobre la pertinencia de `purrr` para tareas de este tipo.  


```{r, eval=F}
nested_for <- function(v1, v2) {
  for (x in v1) {
    for (y in v2){
      print(paste(x, y))
    }
  }
}

nested_for(1:3, 5:8)
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la 游 (Bonus)

Si quieres practicar m치s, puedes realizar el siguiente ejercicio. No es parte de la evaluaci칩n, pero te puede dar puntos extras en caso de que no obtengas todo el puntaje en alguno de los ejercicios anteriores.    

Con los datos de la ENE y **siempre utilizando purrr**, realiza las siguientes tareas:

- Carga todos los trimestres de 2022 en una lista
- Escribe una funci칩n llamada get_employment_sample que reciba un dataframe y devuelva la cantidad de ocupados sin expandir. La categor칤a 1 de la variable *activ* muestra a los ocupados.    
- Usando get_employment_sample, genera un gr치fico que muestre la cantidad de ocupados y no ocupados para cada uno de los trimestres.
- Guarda cada uno de los gr치ficos en una carpeta de tu computador en formato jpg o pdf.  
- Abre un rmd y carga todos los gr치ficos guardados (usando purrr)
- Genera un pdf o html que tenga en su interior los gr치ficos

Para los 칰ltimos 2 pasos, deber치s empujar al repositorio, adem치s, el archivo rmd

---

class: center, middle

.linea-superior[]
.linea-inferior[]

<img src="imagenes/logo_portada2.png" width="200" />

## Capacitaci칩n en R y herramientas de productividad - nivel intermedio

## Proyecto Ciencia de Datos

## Funcionales
