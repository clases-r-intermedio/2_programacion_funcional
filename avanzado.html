<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Capacitaci贸n paquete calidad</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="date" content="2022-06-15" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci贸n en R avanzado

## Proyecto Estrat茅gico Servicios Compartidos para la Producci贸n Estad铆stica

### Agosto 2022





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Estructura del taller

**Objetivos de la clase**

- "Loops" en dplyr

--

- Repaso de funciones en `R`

--

- Funcionales

--

- Programaci贸n con dplyr (evaluaciones no est谩ndar)

---


class: inverse, center, middle

# I. "Loops" en dplyr


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# "Loops" en dplyr

### Necesito normalizar todas las columnas de mi dataset

$$ norm = \frac{x - min(x)}{max(x) - min(x)}    $$

--





```r
mtcars2 &lt;- mtcars
for (var in names(mtcars)) {
  mtcars2[[var]] &lt;- (mtcars[[var]] - min(mtcars[[var]])) / (max(mtcars[[var]]) - min(mtcars[[var]]))
}
```



```
##                     mpg cyl      disp
## Mazda RX4     0.4510638 0.5 0.2217511
## Mazda RX4 Wag 0.4510638 0.5 0.2217511
```

--

### Estilo `dplyr`


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_all(~ (. - min(.)) / (max(.) - min(.)) ) 
```


```
##                     mpg cyl      disp
## Mazda RX4     0.4510638 0.5 0.2217511
## Mazda RX4 Wag 0.4510638 0.5 0.2217511
```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Solo para algunas variables

### Solo me interesa `mpg` y `disp`


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_at(vars(mpg, disp), ~ (. - min(.)) / (max(.) - min(.)) )
```

--

### Quiero crear variables nuevas, en lugar de sobrescribr



```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_at(vars(mpg, disp),  list(norm = ~(. - min(.)) / (max(.) - min(.)) ))
```


```r
names(mtcars2)
```

```
##  [1] "mpg"       "cyl"       "disp"      "hp"        "drat"      "wt"       
##  [7] "qsec"      "vs"        "am"        "gear"      "carb"      "mpg_norm" 
## [13] "disp_norm"
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Solo para algunas variables


### La sintaxis de mutate_at es muy clara, pero est谩 quedando obsoleta 

--


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate(across(c("mpg", "disp") , .fns =  list(norm = ~(. - min(.)) / (max(.) - min(.)) )))
```

--

### Podemos adecuar los nombres a nuestro gusto


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate(across(c("mpg", "disp") , .fns =  list(norm = ~(. - min(.)) / (max(.) - min(.)) ),
                .names = "{.col}_{.fn}"))

names(mtcars2)
```

```
##  [1] "mpg"       "cyl"       "disp"      "hp"        "drat"      "wt"       
##  [7] "qsec"      "vs"        "am"        "gear"      "carb"      "mpg_norm" 
## [13] "disp_norm"
```

--

### Operar sobre todas las variables num茅ricas



```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_if(is.numeric,  list(norm =  ~(. - min(.)) / (max(.) - min(.)) ))
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones complejas


### 驴Qu茅 pasa si necesito hacer una operaci贸n compleja sobre los datos?

.pull-left[
- Normalizar
- Sumar algo
- Dividir por algo

]

.pull-right[
&lt;img src="https://media.giphy.com/media/a5viI92PAF89q/giphy.gif" width="200" /&gt;
]

--

### Opci贸n "carretera" 


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_at(vars(mpg, disp),  list(norm = ~(. - min(.)) / (max(.) - min(.)) )) %&gt;% 
  mutate_at(vars(mpg_norm, disp_norm),  ~(. + mean(.))) %&gt;% 
  mutate_at(vars(mpg_norm, disp_norm),  ~(. / median(.)))
```



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones complejas 

### Podemos construir una funci贸n y luego usarla dentro de `mutate_at`


```r
hacer_calculos &lt;- function(x) {
  normalizar &lt;-  (x - min(x)) / (max(x) - min(x))
  norm_media &lt;-  normalizar + mean(normalizar)
  norm_mediana &lt;- norm_media / median(norm_media)
  return(norm_mediana)
}

mtcars2 &lt;- mtcars %&gt;% 
  mutate_at(vars(mpg, disp),  list(norm = hacer_calculos) ) 
```

.center[
### En las pr贸ximas l谩minas haremos un repaso de funciones
]

--

### Alternativamente


```r
mtcars2 &lt;- mtcars %&gt;% 
  mutate_at(vars(mpg, disp),  list(norm = ~hacer_calculos(.) ) ) 
```



---

class: inverse, center, middle

# II. Repaso ~~breve~~  de funciones


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

Las funciones tienen 3 componentes:

- `body`
- `formals` (argumentos)
- `enviroment`



```r
sumar_xy &lt;- function(x, y) {
  x + y
}
```


```r
body(sumar_xy)
```

```
## {
##     x + y
## }
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones


```r
formals(sumar_xy)
```

```
## $x
## 
## 
## $y
```
--


```r
environment(sumar_xy)
```

```
## &lt;environment: R_GlobalEnv&gt;
```
--


```r
wrapper &lt;- function() {
  sumar_xy &lt;- function(x, y) {
    x + y
  }
  return(environment(sumar_xy))  
}

wrapper
```

```
## function() {
##   sumar_xy &lt;- function(x, y) {
##     x + y
##   }
##   return(environment(sumar_xy))  
## }
```
### Vemos que el ambiente ya no es R_GlobalEnv 

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### *Scope* de una funci贸n



```r
z &lt;- 3
crear_z &lt;- function() {
  z &lt;- 100
  return(z)
}

crear_z()
```

```
## [1] 100
```

```r
print(z)
```

```
## [1] 3
```
--

### La variable z vive en el *scope* de `crear_z` y no afecta a z inicial  



---


background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### Las funciones buscan variables "hacia arriba"


```r
sumar_xy &lt;- function(x, y) {
  x + y + z
}
sumar_xy(1, 2)
```

```
## [1] 6
```

--

### 驴Qu茅 devuelve la funci贸n sumar_xy?


```r
z &lt;- 1
sumar_xy &lt;- function(x, y) {
  z &lt;- 100
  x + y + z
}
sumar_xy(1, 2)
```

--


```
## [1] 103
```
### `z` asume el primer valor encontrado



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### 驴Qu茅 devuelve la funci贸n sumar_xy?



```r
z &lt;- 1
sumar_xy &lt;- function(x, y) {
  z &lt;- 100
  interna &lt;- function(){
    c(x + y + z)
  }
  
  interna()
  
}
sumar_xy(1, 2)
```
--



```
## [1] 103
```
### La funci贸n `interna` encontr贸 a `x = 1`, `y = 2` y `z = 100`,  



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### 驴Qu茅 devuelve `sumar_xy`?


```r
z &lt;- 1
externa &lt;- function(){
  c(x + y + z)
}
sumar_xy &lt;- function(x, y) {
  z &lt;- 100
  externa()
}
*sumar_xy(1, 2)
```
--


```
## Error in externa(): objeto 'x' no encontrado
```
.pull-left[
&lt;img src="https://media.giphy.com/media/a5viI92PAF89q/giphy.gif" width="250" /&gt;
]

--

.pull-right[
### Las funciones buscan primero en el ambiente en el que fueron creadas

### `externa` fue creada en el mismo ambiente que `z = 1`

]





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### Reparemos el script anterior 



```r
z &lt;- 1
externa &lt;- function(x, y){
    c(x + y + z)
}
sumar_xy &lt;- function(x, y) {
  z &lt;- 100
* externa(x, y)
}
sumar_xy(1, 2)
```
--


```
## [1] 4
```

--

.center[
&lt;img src="https://media.giphy.com/media/iIHBIgCIBlE4IoKm7w/giphy.gif" width="200" /&gt;
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones


.pull-left[
### Evaluaci贸n *lazy*  
]

.pull-right[
&lt;img src="https://www.inventorsdigest.com/wp-content/uploads/2018/01/lazy-sloth-1080x640.gif" width="200" /&gt;
]



```r
sumar_xyz &lt;- function(x, y, z) {
  x + y
}
sumar_xyz(1, 2)
```

```
## [1] 3
```
--

### La variable `z` no se eval煤a hasta que realmente se necesita 


```r
sumar_xyz &lt;- function(x, y, z) {
  x + y + z
}
sumar_xyz(1, 2)
```

```
## Error in sumar_xyz(1, 2): el argumento "z" est谩 ausente, sin valor por omisi贸n
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Repaso de funciones

### En otros lenguajes, la evaluaci贸n no es *lazy*




```python
def sumar_xyz(x, y, z):
  return(x + y)
print(sumar_xyz(1, 2))
```

```
## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: sumar_xyz() missing 1 required positional argument: 'z'
```

### `python` utiliza *call by value* (CBV)


---


class: inverse, center, middle

# III. functionals 

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci贸n a funcionales (functionals)


*"To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs."*

- Bjarne Stroustrup

--

Una "funcional" (*functional*) es una funci贸n que recibe como input otra funci贸n


```r
randomise &lt;- function(f) f(runif(10))
```
--

`randomise` recibe una funci贸n y hace algo con un vector de 10 n煤meros aleatorios


```r
randomise(mean)
```

```
## [1] 0.5632679
```

```r
randomise(sum)
```

```
## [1] 5.40212
```

```r
randomise(median)
```

```
## [1] 0.4867065
```





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci贸n a funcionales (functionals)

Es muy probable que ustedes hayan usados funcionales con `R` base

- `apply`, `lapply`, `sapply` 

--

Los loops tienen mala fama en `R`

--

T铆picamente, las funcionales se usan como alternativa a los *loops*

--

Nosotros trabajaremos con el paquete `purrr`


```r
library(purrr)
```


.center[
&lt;img src="imagenes/purrr.png" width="200" /&gt;
]



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mi primera funcional

Funci贸n que calcula el triple del input


```r
triple &lt;- function(x) x * 3
```

--

`map` lleva el vector `1:3` hacia la funci贸n triple


```r
map(1:3, triple)
```

```
## [[1]]
## [1] 3
## 
## [[2]]
## [1] 6
## 
## [[3]]
## [1] 9
```



.center[
&lt;img src="https://d33wubrfki0l68.cloudfront.net/f0494d020aa517ae7b1011cea4c4a9f21702df8b/2577b/diagrams/functionals/map.png" width="200" /&gt;
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# 驴Qu茅 tienen que ver los mapas?

.center[
&lt;img src="imagenes/mapa.png" width="400" /&gt;
]


--

.center[
&lt;img src="imagenes/mapear_funcion.png" width="400" /&gt;
]


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ventajas de `purrr`

Permite abstraernos de lo que hace la funci贸n

--

Tenemos claridad de lo que entra y sale de la funci贸n 

- `map` devuelve una lista
- `map_int` devuelve vector de enteros
- `map_dbl` devuelve vector de reales
- `map_chr` devuelve vector de characters
- `map_df` devuelve un dataframe


```r
triple_chr &lt;- function(x) as.character(x * 3)
map_int(1:3, triple_chr)
```

```
## Error: Can't coerce element 1 from a character to a integer
```

```r
map_chr(1:3, triple_chr)
```

```
## [1] "3" "6" "9"
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con listas anidadas

### La funci贸n `mean` se eval煤a en cada uno de los vectores de la lista


```r
lista_vectores &lt;- list(1:3, 1:10, 2:9, 1)
map_dbl(lista_vectores, mean)
```

```
## [1] 2.0 5.5 5.5 1.0
```
--

### 驴C贸mo uso esto en un dataframe?


.center[
&lt;img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" /&gt;
]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con dataframes

### En `R`, los `dataframes` son listas con vectores de la misma longitud


```r
typeof(mtcars)
```

```
## [1] "list"
```
--


```r
map_dbl(mtcars, mean)
```

```
##        mpg        cyl       disp         hp       drat         wt       qsec 
##  20.090625   6.187500 230.721875 146.687500   3.596563   3.217250  17.848750 
##         vs         am       gear       carb 
##   0.437500   0.406250   3.687500   2.812500
```

.center[
&lt;img src="https://media.giphy.com/media/l3V0dy1zzyjbYTQQM/giphy.gif" width="250" /&gt;
]





---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Trabajando con m谩s argumentos

### 驴Qu茅 pasa si queremos usar m谩s argumentos?


```r
lista_vectores &lt;- list(1:3, c(1:10, NA))
map_dbl(lista_vectores, ~mean(.x, na.rm = TRUE))
```

```
## [1] 2.0 5.5
```

`.x` toma el valor de los elementos que est谩n dentro de `lista_vectores` 

El par谩metro que var铆a va a la izquierda y el par谩metro fijo a la derecha

--

.center[
&lt;img src="https://d33wubrfki0l68.cloudfront.net/e1b3536a7556aef348f546a79277125c419a5fdc/0c0a1/diagrams/functionals/map-arg.png" width="400" /&gt;
]



---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Flujo de trabajo con purrr

### Separamos el dataset usando `year`


```r
library(gapminder)
gapminder_years &lt;- gapminder %&gt;% 
  split(gapminder$year)
```

--

### Estimar un modelo para cada a帽o



```r
gapminder_years %&gt;% 
  map(~lm(lifeExp ~ gdpPercap, data = .x)) %&gt;% # estimar modelo 
  map(coef) %&gt;% # extraer coeficientes
  map_dbl(2) # extraer el segundo elemento 
```

```
##         1952         1957         1962         1967         1972         1977 
## 0.0003646691 0.0003764248 0.0005348708 0.0006950551 0.0004929443 0.0008322108 
##         1982         1987         1992         1997         2002         2007 
## 0.0010065630 0.0009551094 0.0008760226 0.0007996589 0.0007506730 0.0006371341
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando 2 inputs 

### La funci贸n `media_sumar` calcula la media y suma un valor


```r
media_sumar &lt;- function(vector, valor) {
  mean(vector) + valor
}
```

### Queremos que la funci贸n itere sobre `lista_vectores` y sobre `valores`


```r
lista_vectores &lt;- list(1:3, 1:5, 2:5)
valores &lt;- c(2, 3, 8)
```

--


```r
map2_dbl(lista_vectores, valores, media_sumar)
```

```
## [1]  4.0  6.0 11.5
```

.center[
&lt;img src="https://d33wubrfki0l68.cloudfront.net/f5cddf51ec9c243a7c13732b0ce46b0868bf8a31/501a8/diagrams/functionals/map2.png" width="300" /&gt;
]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando *n* cantidad de inputs 

### Necesitamos iterar sobre 3 vectores


```r
media_sumar_dividir &lt;- function(vector, valor_suma, valor_division) {
  (mean(vector) + valor_suma) / valor_division
}

lista_vectores &lt;- list(1:3, 1:5, 2:5)
valores_suma &lt;- c(2, 3, 8)
valores_division &lt;- c(2, 1, 9)
```

--


```r
pmap_dbl(list(lista_vectores, valores_suma, valores_division), media_sumar_dividir)
```

```
## [1] 2.000000 6.000000 1.277778
```


.center[
&lt;img src="https://d33wubrfki0l68.cloudfront.net/2eb2eefe34ad6d114da2a22df42deac8511b4788/5a538/diagrams/functionals/pmap-arg.png" width="300" /&gt;
]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Remover *side-effects* 

### A veces, nos interesa una funci贸n por sus *side-effects*


```r
animales &lt;- c("perro", "gato", "elefante")
map(animales, print)
```

```
## [1] "perro"
## [1] "gato"
## [1] "elefante"
```

```
## [[1]]
## [1] "perro"
## 
## [[2]]
## [1] "gato"
## 
## [[3]]
## [1] "elefante"
```
--

### `map` est谩 creando una lista y, adem谩s, se imprimiendo los valores

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando `walk`


.center[
&lt;img src="https://www.musicme.cl/wp-content/uploads/2021/07/ab67616d0000b273347c0a40c1e3f0c890a6d9d6.jpg" width="300" /&gt;
]

--


```r
walk(animales, print)
```

```
## [1] "perro"
## [1] "gato"
## [1] "elefante"
```

### Ahora solo estamos imprimiendo los strings

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usando `walk`

### Necesito escribir archivos  


```r
continentes &lt;- split(gapminder, gapminder$continent)
```


```r
library(feather)
files &lt;- paste0("data/", names(continentes), ".feather")
walk2(continentes, files, write_feather)
```


---


class: inverse, center, middle

# IV. Programaci贸n con dplyr


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci贸n a la programaci贸n

### 驴Han intentado programar una funci贸n usando dplyr?

--

### Queremos una funci贸n que calcule m铆nimo, m谩ximo, media y mediana 


```r
calcular_cosas &lt;- function(data, var) {
  data %&gt;% 
    summarise(min = min(var),
              max = max(var),
              mean = mean(var),
              median = median(var)
              )
}

calcular_cosas(gapminder, pop)
```

```
## Error in `summarise()`:
## ! Problem while computing `min = min(var)`.
## Caused by error:
## ! objeto 'pop' no encontrado
```


.center[
&lt;img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" /&gt;
]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Introducci贸n a la programaci贸n

### Cambiemos un par de cosas



```r
library(rlang)
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var)

  data %&gt;% 
    summarise(min = min(!!enquo_var),
              max = max(!!enquo_var),
              mean = mean(!!enquo_var),
              median = median(!!enquo_var)
              )
}

calcular_cosas(gapminder, pop)
```

```
## # A tibble: 1 x 4
##     min        max      mean   median
##   &lt;int&gt;      &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 60011 1318683096 29601212. 7023596.
```


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Evaluaciones no est谩ndar

### En `R`, los argumentos pueden ser *evaluados* o *quoted* (驴citados?)  

- evaluados: situaci贸n m谩s usual en R
- quoted: los argumentos son procesados de una manera "at铆pica" (evaluaci贸n no est谩ndar)

--

### Para saber si un argumento es quoted o evaluado, simplemente ejecutamos el argumento fuera de la funci贸n


```r
pop
```

```
## Error in eval(expr, envir, enclos): objeto 'pop' no encontrado
```
--

### Si la ejecuci贸n no funciona, el argumento es quoted


---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejemplos de argumentos quoted y evaluados

### Argumentos evaluados


```r
sum(mtcars$am)
class(mtcars)
```

--

### Argumentos quoted


```r
library(dplyr)

by_cyl &lt;- mtcars %&gt;%
  summarise(mean = mean(mpg)) 

calcular_cosas(gapminder, pop) # &lt;&lt;
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

### Evaluar de manera no est谩ndar consiste en atrapar expresiones y evaluarlas en otro momento


```r
expr(x + y)
```

```
## x + y
```
--




```r
devolver_expresion &lt;- function(x) {
  expr(x)
}

devolver_expresion(a + b)
```

```
## x
```
### La funci贸n `expr` es demasiado literal

--

### Podemos usar enexpr (enrich) 


```r
devolver_expresion &lt;- function(x) {
  enexpr(x)
}

devolver_expresion(a + b)
```

```
## a + b
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

### Volviendo a nuestra funci贸n `calcular_cosas`...
 

```r
calcular_cosas &lt;- function(data, var) {
* enquo_var &lt;- enexpr(var)

  data %&gt;% 
    summarise(min = min(!!enquo_var),
              max = max(!!enquo_var),
              mean = mean(!!enquo_var),
              median = median(!!enquo_var)
              )
}
```

--

### Ya sabemos qu茅 significa la primera l铆nea


--



```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var) 
  return(enquo_var)
}
calcular_cosas(var = pop)
```

```
## pop
```





---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Expresiones

### 驴Qu茅 significa esto `min(!!enquo_var)` ?

&lt;img src="https://media.giphy.com/media/xUPGcz2H1TXdCz4suY/giphy.gif" width="150" /&gt;

--

### Una vez que la expresi贸n se "congela", es necesario evaluarla

### El operador bang-bang (!!) hace *unquoting*

--


```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var) 

  data %&gt;% 
*   summarise(min = min(!!enquo_var))
}

calcular_cosas(gapminder, pop)
```

```
## # A tibble: 1 x 1
##     min
##   &lt;int&gt;
## 1 60011
```


### Estamos evaluando la variable enquo_var

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usar el c贸digo del usario 

### 驴Qu茅 pasa si queremos una funci贸n que use el nombre de un par谩metro, para nombrar una variable?


### Idea n煤mero 1


```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var) 

  data %&gt;% 
*   summarise(var = min(!!enquo_var))
}
calcular_cosas(gapminder, pop)
```

```
## # A tibble: 1 x 1
##     var
##   &lt;int&gt;
## 1 60011
```

--

### `R` fue demasiado literal

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Usar el c贸digo del usario 

### Idea n煤mero 2


```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var) 

  data %&gt;% 
    summarise(!!enquo_var = min(!!enquo_var)) 
}
calcular_cosas(gapminder, pop)
```

```
## Error: &lt;text&gt;:5:27: inesperado '='
## 4:   data %&gt;% 
## 5:     summarise(!!enquo_var =
##                              ^
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operador :=

### Debemos resolver el problema con un nuevo operador


```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- enexpr(var) 

  data %&gt;% 
*   summarise(!!enquo_var := min(!!enquo_var))
}
calcular_cosas(gapminder, pop)
```

```
## # A tibble: 1 x 1
##     pop
##   &lt;int&gt;
## 1 60011
```
--

### Si queremos entregar un string como input podemos usar `sym` 

### `sym` convierte un string en un s铆mbolo. Esta operaci贸n se denomina *parsing*


```r
calcular_cosas &lt;- function(data, var) {
  enquo_var &lt;- sym(var)
  data %&gt;% 
*   summarise(!!enquo_var  := min(!!enquo_var))
}
calcular_cosas(gapminder, "pop")
```

```
## # A tibble: 1 x 1
##     pop
##   &lt;int&gt;
## 1 60011
```

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Parsing

### Otra opci贸n es usar la funci贸n `parse_expr` de `rlang`


```r
calcular_cosas &lt;- function(data, var) {
* enquo_var &lt;- parse_expr(var)
  data %&gt;% 
    summarise(!!enquo_var  := min(!!enquo_var))
}
calcular_cosas(gapminder, "pop")
```

```
## # A tibble: 1 x 1
##     pop
##   &lt;int&gt;
## 1 60011
```
---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Nueva sintaxis

### Hace un tiempo existe el operador embrace `{{}}`


```r
calcular_cosas &lt;- function(data, var) {
  data %&gt;% 
    summarise({{var}} := min({{var}}))
}
calcular_cosas(gapminder, pop)
```

```
## # A tibble: 1 x 1
##     pop
##   &lt;int&gt;
## 1 60011
```

### Nos evita dar una vuelta larga, pero no habr铆amos aprendido sobre evaluaciones no est谩ndar 





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Aplicaci贸n en purrr

### Podemos usar todas estas ideas en el paquete purrr

### `imap` permite iterar sobre una lista y sus nombres


```r
continents &lt;- split(gapminder, gapminder$continent)
```



```r
continents2 &lt;- continents %&gt;% 
  
  imap(~mutate(.x, !!sym(.y) := log10(pop))  )

models &lt;- continents %&gt;% 
  map(~lm(lifeExp ~ gdpPercap, data = .x)) %&gt;% # estimar modelo 
  map(coef) %&gt;% # extraer coeficientes
  map_dbl(2)

continents2[[1]] %&gt;% names()
```

```
## [1] "country"   "continent" "year"      "lifeExp"   "pop"       "gdpPercap"
## [7] "Africa"
```

```r
continents2[[2]] %&gt;% names()
```

```
## [1] "country"   "continent" "year"      "lifeExp"   "pop"       "gdpPercap"
## [7] "Americas"
```

```r
names(gapminder)
```

```
## [1] "country"   "continent" "year"      "lifeExp"   "pop"       "gdpPercap"
```




```r
x &lt;- 100
eval_tidy(expr(x + 1), env =  env(x = 2)  )
```

```
## [1] 3
```

```r
weird_env &lt;- env()

`+`(1, 2)
```

```
## [1] 3
```

```r
weird_env$`+` &lt;- function(x, y) {
  paste(x , y)
}


weird_env$`+`
```

```
## function(x, y) {
##   paste(x , y)
## }
```

```r
eval_tidy(expr("un" + "saludo"), env =  weird_env  )
```

```
## [1] "un saludo"
```

```r
`(` &lt;- function(e1) {
  if (is.numeric(e1) &amp;&amp; runif(1) &lt; 0.1) {
    e1 + 1
  } else {
    e1
  }
}


nuevo_mas &lt;- function(...) {
  `+` &lt;- function(x, y) {
    if (is.character(x) | is.character(y)) {
      paste(...)    
    } else   {
      sum(x, y)
    }
}
  
x + y    

}

test &lt;- function(...) {
  user_params &lt;- list(...)
  
  return(rlang::exprs(user_params) )
}

y &lt;- 3
test(1, x, y)
```

```
## [[1]]
## user_params
```

```r
nuevo_mas(10, 1)
```

```
## [1] 103
```

---

class: center, middle

.linea-superior[]
.linea-inferior[]

&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci贸n en R avanzado

## Proyecto Estrat茅gico Servicios Compartidos para la Producci贸n Estad铆stica

### Diciembre 2021
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "13:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
